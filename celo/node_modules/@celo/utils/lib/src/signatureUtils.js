"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var commentEncryption_1 = require("./commentEncryption");
var ethjsutil = require('ethereumjs-util');
function signMessage(messageHash, privateKey, address) {
    var publicKey = ethjsutil.privateToPublic(ethjsutil.toBuffer(privateKey));
    var derivedAddress = ethjsutil.bufferToHex(ethjsutil.pubToAddress(publicKey));
    if (derivedAddress.toLowerCase() !== address.toLowerCase()) {
        throw new Error('Provided private key does not match address of intended signer');
    }
    var _a = ethjsutil.ecsign(ethjsutil.toBuffer(messageHash), ethjsutil.toBuffer(privateKey)), r = _a.r, s = _a.s, v = _a.v;
    if (!isValidSignature(address, messageHash, v, ethjsutil.bufferToHex(r), ethjsutil.bufferToHex(s))) {
        throw new Error('Unable to validate signature');
    }
    return { v: v, r: ethjsutil.bufferToHex(r), s: ethjsutil.bufferToHex(s) };
}
exports.signMessage = signMessage;
function parseSignature(messageHash, signature, signer) {
    var _a;
    var _b = parseSignatureAsRsv(signature.slice(2)), r = _b.r, s = _b.s, v = _b.v;
    if (isValidSignature(signer, messageHash, v, r, s)) {
        return { v: v, r: r, s: s };
    }
    ;
    (_a = parseSignatureAsVrs(signature.slice(2)), r = _a.r, s = _a.s, v = _a.v);
    if (isValidSignature(signer, messageHash, v, r, s)) {
        return { v: v, r: r, s: s };
    }
    throw new Error('Unable to parse signature');
}
exports.parseSignature = parseSignature;
function parseSignatureAsVrs(signature) {
    var v = parseInt(signature.slice(0, 2), 16);
    var r = "0x" + signature.slice(2, 66);
    var s = "0x" + signature.slice(66, 130);
    if (v < 27) {
        v += 27;
    }
    return { v: v, r: r, s: s };
}
function parseSignatureAsRsv(signature) {
    var r = "0x" + signature.slice(0, 64);
    var s = "0x" + signature.slice(64, 128);
    var v = parseInt(signature.slice(128, 130), 16);
    if (v < 27) {
        v += 27;
    }
    return { r: r, s: s, v: v };
}
function isValidSignature(signer, message, v, r, s) {
    try {
        var publicKey = ethjsutil.ecrecover(ethjsutil.toBuffer(message), v, ethjsutil.toBuffer(r), ethjsutil.toBuffer(s));
        var retrievedAddress = ethjsutil.bufferToHex(ethjsutil.pubToAddress(publicKey));
        return signer.toLowerCase() === retrievedAddress.toLowerCase();
    }
    catch (err) {
        return false;
    }
}
function isValidAddress(address) {
    return (typeof address === 'string' &&
        !ethjsutil.isZeroAddress(address) &&
        ethjsutil.isValidAddress(address));
}
exports.isValidAddress = isValidAddress;
function areAddressesEqual(address1, address2) {
    if (address1) {
        address1 = commentEncryption_1.stripHexLeader(address1.toLowerCase());
    }
    if (address2) {
        address2 = commentEncryption_1.stripHexLeader(address2.toLowerCase());
    }
    return address1 === address2;
}
exports.areAddressesEqual = areAddressesEqual;
exports.SignatureUtils = {
    signMessage: signMessage,
    parseSignature: parseSignature,
    isValidAddress: isValidAddress,
    areAddressesEqual: areAddressesEqual,
};
